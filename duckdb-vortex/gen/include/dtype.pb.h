// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dtype.proto
// Protobuf C++ Version: 5.27.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_dtype_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dtype_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dtype_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dtype_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_dtype_2eproto;
namespace vortex {
namespace dtype {
class Binary;
struct BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Bool;
struct BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class DType;
struct DTypeDefaultTypeInternal;
extern DTypeDefaultTypeInternal _DType_default_instance_;
class Extension;
struct ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FieldPath;
struct FieldPathDefaultTypeInternal;
extern FieldPathDefaultTypeInternal _FieldPath_default_instance_;
class List;
struct ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class Null;
struct NullDefaultTypeInternal;
extern NullDefaultTypeInternal _Null_default_instance_;
class Primitive;
struct PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class Struct;
struct StructDefaultTypeInternal;
extern StructDefaultTypeInternal _Struct_default_instance_;
class Utf8;
struct Utf8DefaultTypeInternal;
extern Utf8DefaultTypeInternal _Utf8_default_instance_;
}  // namespace dtype
}  // namespace vortex
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace vortex {
namespace dtype {
enum PType : int {
  U8 = 0,
  U16 = 1,
  U32 = 2,
  U64 = 3,
  I8 = 4,
  I16 = 5,
  I32 = 6,
  I64 = 7,
  F16 = 8,
  F32 = 9,
  F64 = 10,
  PType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PType_IsValid(int value);
extern const uint32_t PType_internal_data_[];
constexpr PType PType_MIN = static_cast<PType>(0);
constexpr PType PType_MAX = static_cast<PType>(10);
constexpr int PType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
PType_descriptor();
template <typename T>
const std::string& PType_Name(T value) {
  static_assert(std::is_same<T, PType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PType_Name().");
  return PType_Name(static_cast<PType>(value));
}
template <>
inline const std::string& PType_Name(PType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool PType_Parse(absl::string_view name, PType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PType>(
      PType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Utf8 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Utf8) */ {
 public:
  inline Utf8() : Utf8(nullptr) {}
  ~Utf8() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Utf8(
      ::google::protobuf::internal::ConstantInitialized);

  inline Utf8(const Utf8& from) : Utf8(nullptr, from) {}
  inline Utf8(Utf8&& from) noexcept
      : Utf8(nullptr, std::move(from)) {}
  inline Utf8& operator=(const Utf8& from) {
    CopyFrom(from);
    return *this;
  }
  inline Utf8& operator=(Utf8&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Utf8& default_instance() {
    return *internal_default_instance();
  }
  static inline const Utf8* internal_default_instance() {
    return reinterpret_cast<const Utf8*>(
        &_Utf8_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Utf8& a, Utf8& b) { a.Swap(&b); }
  inline void Swap(Utf8* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Utf8* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Utf8* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Utf8>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Utf8& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Utf8& from) { Utf8::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Utf8* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Utf8"; }

 protected:
  explicit Utf8(::google::protobuf::Arena* arena);
  Utf8(::google::protobuf::Arena* arena, const Utf8& from);
  Utf8(::google::protobuf::Arena* arena, Utf8&& from) noexcept
      : Utf8(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNullableFieldNumber = 1,
  };
  // bool nullable = 1;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Utf8)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Utf8_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Utf8& from_msg);
    bool nullable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Primitive final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Primitive) */ {
 public:
  inline Primitive() : Primitive(nullptr) {}
  ~Primitive() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Primitive(
      ::google::protobuf::internal::ConstantInitialized);

  inline Primitive(const Primitive& from) : Primitive(nullptr, from) {}
  inline Primitive(Primitive&& from) noexcept
      : Primitive(nullptr, std::move(from)) {}
  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Primitive& operator=(Primitive&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
        &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Primitive& a, Primitive& b) { a.Swap(&b); }
  inline void Swap(Primitive* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Primitive>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Primitive& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Primitive& from) { Primitive::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Primitive* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Primitive"; }

 protected:
  explicit Primitive(::google::protobuf::Arena* arena);
  Primitive(::google::protobuf::Arena* arena, const Primitive& from);
  Primitive(::google::protobuf::Arena* arena, Primitive&& from) noexcept
      : Primitive(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kNullableFieldNumber = 2,
  };
  // .vortex.dtype.PType type = 1;
  void clear_type() ;
  ::vortex::dtype::PType type() const;
  void set_type(::vortex::dtype::PType value);

  private:
  ::vortex::dtype::PType _internal_type() const;
  void _internal_set_type(::vortex::dtype::PType value);

  public:
  // bool nullable = 2;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Primitive)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Primitive_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Primitive& from_msg);
    int type_;
    bool nullable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Null final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:vortex.dtype.Null) */ {
 public:
  inline Null() : Null(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Null(
      ::google::protobuf::internal::ConstantInitialized);

  inline Null(const Null& from) : Null(nullptr, from) {}
  inline Null(Null&& from) noexcept
      : Null(nullptr, std::move(from)) {}
  inline Null& operator=(const Null& from) {
    CopyFrom(from);
    return *this;
  }
  inline Null& operator=(Null&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Null& default_instance() {
    return *internal_default_instance();
  }
  static inline const Null* internal_default_instance() {
    return reinterpret_cast<const Null*>(
        &_Null_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Null& a, Null& b) { a.Swap(&b); }
  inline void Swap(Null* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Null* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Null* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Null>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Null& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Null& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Null"; }

 protected:
  explicit Null(::google::protobuf::Arena* arena);
  Null(::google::protobuf::Arena* arena, const Null& from);
  Null(::google::protobuf::Arena* arena, Null&& from) noexcept
      : Null(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:vortex.dtype.Null)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Null_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Null& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Field final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Field(
      ::google::protobuf::internal::ConstantInitialized);

  inline Field(const Field& from) : Field(nullptr, from) {}
  inline Field(Field&& from) noexcept
      : Field(nullptr, std::move(from)) {}
  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  enum FieldTypeCase {
    kName = 1,
    FIELD_TYPE_NOT_SET = 0,
  };
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
        &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Field& a, Field& b) { a.Swap(&b); }
  inline void Swap(Field* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Field>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Field& from) { Field::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Field* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Field"; }

 protected:
  explicit Field(::google::protobuf::Arena* arena);
  Field(::google::protobuf::Arena* arena, const Field& from);
  Field(::google::protobuf::Arena* arena, Field&& from) noexcept
      : Field(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  void clear_field_type();
  FieldTypeCase field_type_case() const;
  // @@protoc_insertion_point(class_scope:vortex.dtype.Field)
 private:
  class _Internal;
  void set_has_name();
  inline bool has_field_type() const;
  inline void clear_has_field_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      31, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Field_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Field& from_msg);
    union FieldTypeUnion {
      constexpr FieldTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr name_;
    } field_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Bool final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Bool) */ {
 public:
  inline Bool() : Bool(nullptr) {}
  ~Bool() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Bool(
      ::google::protobuf::internal::ConstantInitialized);

  inline Bool(const Bool& from) : Bool(nullptr, from) {}
  inline Bool(Bool&& from) noexcept
      : Bool(nullptr, std::move(from)) {}
  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bool& operator=(Bool&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
        &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Bool& a, Bool& b) { a.Swap(&b); }
  inline void Swap(Bool* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bool* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Bool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Bool& from) { Bool::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bool* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Bool"; }

 protected:
  explicit Bool(::google::protobuf::Arena* arena);
  Bool(::google::protobuf::Arena* arena, const Bool& from);
  Bool(::google::protobuf::Arena* arena, Bool&& from) noexcept
      : Bool(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNullableFieldNumber = 1,
  };
  // bool nullable = 1;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Bool)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Bool_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Bool& from_msg);
    bool nullable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Binary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Binary) */ {
 public:
  inline Binary() : Binary(nullptr) {}
  ~Binary() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Binary(
      ::google::protobuf::internal::ConstantInitialized);

  inline Binary(const Binary& from) : Binary(nullptr, from) {}
  inline Binary(Binary&& from) noexcept
      : Binary(nullptr, std::move(from)) {}
  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binary& operator=(Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
        &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Binary& a, Binary& b) { a.Swap(&b); }
  inline void Swap(Binary* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Binary* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Binary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Binary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Binary& from) { Binary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Binary* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Binary"; }

 protected:
  explicit Binary(::google::protobuf::Arena* arena);
  Binary(::google::protobuf::Arena* arena, const Binary& from);
  Binary(::google::protobuf::Arena* arena, Binary&& from) noexcept
      : Binary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNullableFieldNumber = 1,
  };
  // bool nullable = 1;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Binary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Binary_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Binary& from_msg);
    bool nullable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class FieldPath final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.FieldPath) */ {
 public:
  inline FieldPath() : FieldPath(nullptr) {}
  ~FieldPath() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FieldPath(
      ::google::protobuf::internal::ConstantInitialized);

  inline FieldPath(const FieldPath& from) : FieldPath(nullptr, from) {}
  inline FieldPath(FieldPath&& from) noexcept
      : FieldPath(nullptr, std::move(from)) {}
  inline FieldPath& operator=(const FieldPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldPath& operator=(FieldPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldPath* internal_default_instance() {
    return reinterpret_cast<const FieldPath*>(
        &_FieldPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FieldPath& a, FieldPath& b) { a.Swap(&b); }
  inline void Swap(FieldPath* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldPath* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldPath* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FieldPath>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldPath& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FieldPath& from) { FieldPath::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FieldPath* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.FieldPath"; }

 protected:
  explicit FieldPath(::google::protobuf::Arena* arena);
  FieldPath(::google::protobuf::Arena* arena, const FieldPath& from);
  FieldPath(::google::protobuf::Arena* arena, FieldPath&& from) noexcept
      : FieldPath(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 1,
  };
  // repeated .vortex.dtype.Field path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::vortex::dtype::Field* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>* mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>* _internal_mutable_path();
  public:
  const ::vortex::dtype::Field& path(int index) const;
  ::vortex::dtype::Field* add_path();
  const ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>& path() const;
  // @@protoc_insertion_point(class_scope:vortex.dtype.FieldPath)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FieldPath_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FieldPath& from_msg);
    ::google::protobuf::RepeatedPtrField< ::vortex::dtype::Field > path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class DType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.DType) */ {
 public:
  inline DType() : DType(nullptr) {}
  ~DType() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DType(
      ::google::protobuf::internal::ConstantInitialized);

  inline DType(const DType& from) : DType(nullptr, from) {}
  inline DType(DType&& from) noexcept
      : DType(nullptr, std::move(from)) {}
  inline DType& operator=(const DType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DType& operator=(DType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DType& default_instance() {
    return *internal_default_instance();
  }
  enum DtypeTypeCase {
    kNull = 1,
    kBool = 2,
    kPrimitive = 3,
    kUtf8 = 5,
    kBinary = 6,
    kStruct = 7,
    kList = 8,
    kExtension = 9,
    DTYPE_TYPE_NOT_SET = 0,
  };
  static inline const DType* internal_default_instance() {
    return reinterpret_cast<const DType*>(
        &_DType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(DType& a, DType& b) { a.Swap(&b); }
  inline void Swap(DType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DType& from) { DType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.DType"; }

 protected:
  explicit DType(::google::protobuf::Arena* arena);
  DType(::google::protobuf::Arena* arena, const DType& from);
  DType(::google::protobuf::Arena* arena, DType&& from) noexcept
      : DType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNullFieldNumber = 1,
    kBoolFieldNumber = 2,
    kPrimitiveFieldNumber = 3,
    kUtf8FieldNumber = 5,
    kBinaryFieldNumber = 6,
    kStructFieldNumber = 7,
    kListFieldNumber = 8,
    kExtensionFieldNumber = 9,
  };
  // .vortex.dtype.Null null = 1;
  bool has_null() const;
  private:
  bool _internal_has_null() const;

  public:
  void clear_null() ;
  const ::vortex::dtype::Null& null() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Null* release_null();
  ::vortex::dtype::Null* mutable_null();
  void set_allocated_null(::vortex::dtype::Null* value);
  void unsafe_arena_set_allocated_null(::vortex::dtype::Null* value);
  ::vortex::dtype::Null* unsafe_arena_release_null();

  private:
  const ::vortex::dtype::Null& _internal_null() const;
  ::vortex::dtype::Null* _internal_mutable_null();

  public:
  // .vortex.dtype.Bool bool = 2;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;

  public:
  void clear_bool_() ;
  const ::vortex::dtype::Bool& bool_() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Bool* release_bool_();
  ::vortex::dtype::Bool* mutable_bool_();
  void set_allocated_bool_(::vortex::dtype::Bool* value);
  void unsafe_arena_set_allocated_bool_(::vortex::dtype::Bool* value);
  ::vortex::dtype::Bool* unsafe_arena_release_bool_();

  private:
  const ::vortex::dtype::Bool& _internal_bool_() const;
  ::vortex::dtype::Bool* _internal_mutable_bool_();

  public:
  // .vortex.dtype.Primitive primitive = 3;
  bool has_primitive() const;
  private:
  bool _internal_has_primitive() const;

  public:
  void clear_primitive() ;
  const ::vortex::dtype::Primitive& primitive() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Primitive* release_primitive();
  ::vortex::dtype::Primitive* mutable_primitive();
  void set_allocated_primitive(::vortex::dtype::Primitive* value);
  void unsafe_arena_set_allocated_primitive(::vortex::dtype::Primitive* value);
  ::vortex::dtype::Primitive* unsafe_arena_release_primitive();

  private:
  const ::vortex::dtype::Primitive& _internal_primitive() const;
  ::vortex::dtype::Primitive* _internal_mutable_primitive();

  public:
  // .vortex.dtype.Utf8 utf8 = 5;
  bool has_utf8() const;
  private:
  bool _internal_has_utf8() const;

  public:
  void clear_utf8() ;
  const ::vortex::dtype::Utf8& utf8() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Utf8* release_utf8();
  ::vortex::dtype::Utf8* mutable_utf8();
  void set_allocated_utf8(::vortex::dtype::Utf8* value);
  void unsafe_arena_set_allocated_utf8(::vortex::dtype::Utf8* value);
  ::vortex::dtype::Utf8* unsafe_arena_release_utf8();

  private:
  const ::vortex::dtype::Utf8& _internal_utf8() const;
  ::vortex::dtype::Utf8* _internal_mutable_utf8();

  public:
  // .vortex.dtype.Binary binary = 6;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::vortex::dtype::Binary& binary() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Binary* release_binary();
  ::vortex::dtype::Binary* mutable_binary();
  void set_allocated_binary(::vortex::dtype::Binary* value);
  void unsafe_arena_set_allocated_binary(::vortex::dtype::Binary* value);
  ::vortex::dtype::Binary* unsafe_arena_release_binary();

  private:
  const ::vortex::dtype::Binary& _internal_binary() const;
  ::vortex::dtype::Binary* _internal_mutable_binary();

  public:
  // .vortex.dtype.Struct struct = 7;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::vortex::dtype::Struct& struct_() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Struct* release_struct_();
  ::vortex::dtype::Struct* mutable_struct_();
  void set_allocated_struct_(::vortex::dtype::Struct* value);
  void unsafe_arena_set_allocated_struct_(::vortex::dtype::Struct* value);
  ::vortex::dtype::Struct* unsafe_arena_release_struct_();

  private:
  const ::vortex::dtype::Struct& _internal_struct_() const;
  ::vortex::dtype::Struct* _internal_mutable_struct_();

  public:
  // .vortex.dtype.List list = 8;
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::vortex::dtype::List& list() const;
  PROTOBUF_NODISCARD ::vortex::dtype::List* release_list();
  ::vortex::dtype::List* mutable_list();
  void set_allocated_list(::vortex::dtype::List* value);
  void unsafe_arena_set_allocated_list(::vortex::dtype::List* value);
  ::vortex::dtype::List* unsafe_arena_release_list();

  private:
  const ::vortex::dtype::List& _internal_list() const;
  ::vortex::dtype::List* _internal_mutable_list();

  public:
  // .vortex.dtype.Extension extension = 9;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;

  public:
  void clear_extension() ;
  const ::vortex::dtype::Extension& extension() const;
  PROTOBUF_NODISCARD ::vortex::dtype::Extension* release_extension();
  ::vortex::dtype::Extension* mutable_extension();
  void set_allocated_extension(::vortex::dtype::Extension* value);
  void unsafe_arena_set_allocated_extension(::vortex::dtype::Extension* value);
  ::vortex::dtype::Extension* unsafe_arena_release_extension();

  private:
  const ::vortex::dtype::Extension& _internal_extension() const;
  ::vortex::dtype::Extension* _internal_mutable_extension();

  public:
  void clear_dtype_type();
  DtypeTypeCase dtype_type_case() const;
  // @@protoc_insertion_point(class_scope:vortex.dtype.DType)
 private:
  class _Internal;
  void set_has_null();
  void set_has_bool_();
  void set_has_primitive();
  void set_has_utf8();
  void set_has_binary();
  void set_has_struct_();
  void set_has_list();
  void set_has_extension();
  inline bool has_dtype_type() const;
  inline void clear_has_dtype_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DType& from_msg);
    union DtypeTypeUnion {
      constexpr DtypeTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::vortex::dtype::Null* null_;
      ::vortex::dtype::Bool* bool__;
      ::vortex::dtype::Primitive* primitive_;
      ::vortex::dtype::Utf8* utf8_;
      ::vortex::dtype::Binary* binary_;
      ::vortex::dtype::Struct* struct__;
      ::vortex::dtype::List* list_;
      ::vortex::dtype::Extension* extension_;
    } dtype_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Extension final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Extension) */ {
 public:
  inline Extension() : Extension(nullptr) {}
  ~Extension() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Extension(
      ::google::protobuf::internal::ConstantInitialized);

  inline Extension(const Extension& from) : Extension(nullptr, from) {}
  inline Extension(Extension&& from) noexcept
      : Extension(nullptr, std::move(from)) {}
  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extension& operator=(Extension&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Extension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
        &_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Extension& a, Extension& b) { a.Swap(&b); }
  inline void Swap(Extension* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Extension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Extension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Extension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Extension& from) { Extension::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Extension* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Extension"; }

 protected:
  explicit Extension(::google::protobuf::Arena* arena);
  Extension(::google::protobuf::Arena* arena, const Extension& from);
  Extension(::google::protobuf::Arena* arena, Extension&& from) noexcept
      : Extension(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 3,
    kStorageDtypeFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bytes metadata = 3;
  bool has_metadata() const;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // .vortex.dtype.DType storage_dtype = 2;
  bool has_storage_dtype() const;
  void clear_storage_dtype() ;
  const ::vortex::dtype::DType& storage_dtype() const;
  PROTOBUF_NODISCARD ::vortex::dtype::DType* release_storage_dtype();
  ::vortex::dtype::DType* mutable_storage_dtype();
  void set_allocated_storage_dtype(::vortex::dtype::DType* value);
  void unsafe_arena_set_allocated_storage_dtype(::vortex::dtype::DType* value);
  ::vortex::dtype::DType* unsafe_arena_release_storage_dtype();

  private:
  const ::vortex::dtype::DType& _internal_storage_dtype() const;
  ::vortex::dtype::DType* _internal_mutable_storage_dtype();

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Extension)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Extension_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Extension& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::vortex::dtype::DType* storage_dtype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class List final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.List) */ {
 public:
  inline List() : List(nullptr) {}
  ~List() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR List(
      ::google::protobuf::internal::ConstantInitialized);

  inline List(const List& from) : List(nullptr, from) {}
  inline List(List&& from) noexcept
      : List(nullptr, std::move(from)) {}
  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  inline List& operator=(List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const List& default_instance() {
    return *internal_default_instance();
  }
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
        &_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(List& a, List& b) { a.Swap(&b); }
  inline void Swap(List* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const List& from) { List::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(List* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.List"; }

 protected:
  explicit List(::google::protobuf::Arena* arena);
  List(::google::protobuf::Arena* arena, const List& from);
  List(::google::protobuf::Arena* arena, List&& from) noexcept
      : List(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElementTypeFieldNumber = 1,
    kNullableFieldNumber = 2,
  };
  // .vortex.dtype.DType element_type = 1;
  bool has_element_type() const;
  void clear_element_type() ;
  const ::vortex::dtype::DType& element_type() const;
  PROTOBUF_NODISCARD ::vortex::dtype::DType* release_element_type();
  ::vortex::dtype::DType* mutable_element_type();
  void set_allocated_element_type(::vortex::dtype::DType* value);
  void unsafe_arena_set_allocated_element_type(::vortex::dtype::DType* value);
  ::vortex::dtype::DType* unsafe_arena_release_element_type();

  private:
  const ::vortex::dtype::DType& _internal_element_type() const;
  ::vortex::dtype::DType* _internal_mutable_element_type();

  public:
  // bool nullable = 2;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.List)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_List_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const List& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::vortex::dtype::DType* element_type_;
    bool nullable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};
// -------------------------------------------------------------------

class Struct final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:vortex.dtype.Struct) */ {
 public:
  inline Struct() : Struct(nullptr) {}
  ~Struct() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Struct(
      ::google::protobuf::internal::ConstantInitialized);

  inline Struct(const Struct& from) : Struct(nullptr, from) {}
  inline Struct(Struct&& from) noexcept
      : Struct(nullptr, std::move(from)) {}
  inline Struct& operator=(const Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Struct& operator=(Struct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Struct& default_instance() {
    return *internal_default_instance();
  }
  static inline const Struct* internal_default_instance() {
    return reinterpret_cast<const Struct*>(
        &_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Struct& a, Struct& b) { a.Swap(&b); }
  inline void Swap(Struct* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Struct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Struct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Struct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Struct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Struct& from) { Struct::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Struct* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "vortex.dtype.Struct"; }

 protected:
  explicit Struct(::google::protobuf::Arena* arena);
  Struct(::google::protobuf::Arena* arena, const Struct& from);
  Struct(::google::protobuf::Arena* arena, Struct&& from) noexcept
      : Struct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 1,
    kDtypesFieldNumber = 2,
    kNullableFieldNumber = 3,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, std::size_t size);
  void set_names(int index, absl::string_view value);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, std::size_t size);
  void add_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // repeated .vortex.dtype.DType dtypes = 2;
  int dtypes_size() const;
  private:
  int _internal_dtypes_size() const;

  public:
  void clear_dtypes() ;
  ::vortex::dtype::DType* mutable_dtypes(int index);
  ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>* mutable_dtypes();

  private:
  const ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>& _internal_dtypes() const;
  ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>* _internal_mutable_dtypes();
  public:
  const ::vortex::dtype::DType& dtypes(int index) const;
  ::vortex::dtype::DType* add_dtypes();
  const ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>& dtypes() const;
  // bool nullable = 3;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:vortex.dtype.Struct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Struct_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Struct& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::google::protobuf::RepeatedPtrField< ::vortex::dtype::DType > dtypes_;
    bool nullable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dtype_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Null

// -------------------------------------------------------------------

// Bool

// bool nullable = 1;
inline void Bool::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool Bool::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Bool.nullable)
  return _internal_nullable();
}
inline void Bool::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Bool.nullable)
}
inline bool Bool::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Bool::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// Primitive

// .vortex.dtype.PType type = 1;
inline void Primitive::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::vortex::dtype::PType Primitive::type() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Primitive.type)
  return _internal_type();
}
inline void Primitive::set_type(::vortex::dtype::PType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Primitive.type)
}
inline ::vortex::dtype::PType Primitive::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::vortex::dtype::PType>(_impl_.type_);
}
inline void Primitive::_internal_set_type(::vortex::dtype::PType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// bool nullable = 2;
inline void Primitive::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool Primitive::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Primitive.nullable)
  return _internal_nullable();
}
inline void Primitive::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Primitive.nullable)
}
inline bool Primitive::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Primitive::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// Utf8

// bool nullable = 1;
inline void Utf8::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool Utf8::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Utf8.nullable)
  return _internal_nullable();
}
inline void Utf8::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Utf8.nullable)
}
inline bool Utf8::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Utf8::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// Binary

// bool nullable = 1;
inline void Binary::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool Binary::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Binary.nullable)
  return _internal_nullable();
}
inline void Binary::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Binary.nullable)
}
inline bool Binary::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Binary::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// Struct

// repeated string names = 1;
inline int Struct::_internal_names_size() const {
  return _internal_names().size();
}
inline int Struct::names_size() const {
  return _internal_names_size();
}
inline void Struct::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline std::string* Struct::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:vortex.dtype.Struct.names)
  return _s;
}
inline const std::string& Struct::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Struct.names)
  return _internal_names().Get(index);
}
inline std::string* Struct::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Struct.names)
  return _internal_mutable_names()->Mutable(index);
}
inline void Struct::set_names(int index, const std::string& value) {
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Struct.names)
}
inline void Struct::set_names(int index, std::string&& value) {
  _internal_mutable_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vortex.dtype.Struct.names)
}
inline void Struct::set_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vortex.dtype.Struct.names)
}
inline void Struct::set_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vortex.dtype.Struct.names)
}
inline void Struct::set_names(int index, absl::string_view value) {
  _internal_mutable_names()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:vortex.dtype.Struct.names)
}
inline void Struct::add_names(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:vortex.dtype.Struct.names)
}
inline void Struct::add_names(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:vortex.dtype.Struct.names)
}
inline void Struct::add_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vortex.dtype.Struct.names)
}
inline void Struct::add_names(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vortex.dtype.Struct.names)
}
inline void Struct::add_names(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_names()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:vortex.dtype.Struct.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Struct::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vortex.dtype.Struct.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Struct::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vortex.dtype.Struct.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Struct::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Struct::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// repeated .vortex.dtype.DType dtypes = 2;
inline int Struct::_internal_dtypes_size() const {
  return _internal_dtypes().size();
}
inline int Struct::dtypes_size() const {
  return _internal_dtypes_size();
}
inline void Struct::clear_dtypes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtypes_.Clear();
}
inline ::vortex::dtype::DType* Struct::mutable_dtypes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Struct.dtypes)
  return _internal_mutable_dtypes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>* Struct::mutable_dtypes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vortex.dtype.Struct.dtypes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dtypes();
}
inline const ::vortex::dtype::DType& Struct::dtypes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Struct.dtypes)
  return _internal_dtypes().Get(index);
}
inline ::vortex::dtype::DType* Struct::add_dtypes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::vortex::dtype::DType* _add = _internal_mutable_dtypes()->Add();
  // @@protoc_insertion_point(field_add:vortex.dtype.Struct.dtypes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>& Struct::dtypes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vortex.dtype.Struct.dtypes)
  return _internal_dtypes();
}
inline const ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>&
Struct::_internal_dtypes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dtypes_;
}
inline ::google::protobuf::RepeatedPtrField<::vortex::dtype::DType>*
Struct::_internal_mutable_dtypes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dtypes_;
}

// bool nullable = 3;
inline void Struct::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool Struct::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.Struct.nullable)
  return _internal_nullable();
}
inline void Struct::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.Struct.nullable)
}
inline bool Struct::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Struct::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// List

// .vortex.dtype.DType element_type = 1;
inline bool List::has_element_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.element_type_ != nullptr);
  return value;
}
inline void List::clear_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.element_type_ != nullptr) _impl_.element_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::vortex::dtype::DType& List::_internal_element_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::vortex::dtype::DType* p = _impl_.element_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::vortex::dtype::DType&>(::vortex::dtype::_DType_default_instance_);
}
inline const ::vortex::dtype::DType& List::element_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.List.element_type)
  return _internal_element_type();
}
inline void List::unsafe_arena_set_allocated_element_type(::vortex::dtype::DType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.element_type_);
  }
  _impl_.element_type_ = reinterpret_cast<::vortex::dtype::DType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.List.element_type)
}
inline ::vortex::dtype::DType* List::release_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::vortex::dtype::DType* released = _impl_.element_type_;
  _impl_.element_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::vortex::dtype::DType* List::unsafe_arena_release_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:vortex.dtype.List.element_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::vortex::dtype::DType* temp = _impl_.element_type_;
  _impl_.element_type_ = nullptr;
  return temp;
}
inline ::vortex::dtype::DType* List::_internal_mutable_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.element_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::DType>(GetArena());
    _impl_.element_type_ = reinterpret_cast<::vortex::dtype::DType*>(p);
  }
  return _impl_.element_type_;
}
inline ::vortex::dtype::DType* List::mutable_element_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::vortex::dtype::DType* _msg = _internal_mutable_element_type();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.List.element_type)
  return _msg;
}
inline void List::set_allocated_element_type(::vortex::dtype::DType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.element_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.element_type_ = reinterpret_cast<::vortex::dtype::DType*>(value);
  // @@protoc_insertion_point(field_set_allocated:vortex.dtype.List.element_type)
}

// bool nullable = 2;
inline void List::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
}
inline bool List::nullable() const {
  // @@protoc_insertion_point(field_get:vortex.dtype.List.nullable)
  return _internal_nullable();
}
inline void List::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:vortex.dtype.List.nullable)
}
inline bool List::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void List::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// -------------------------------------------------------------------

// Extension

// string id = 1;
inline void Extension::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Extension::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Extension.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Extension::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vortex.dtype.Extension.id)
}
inline std::string* Extension::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Extension.id)
  return _s;
}
inline const std::string& Extension::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Extension::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Extension::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Extension::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:vortex.dtype.Extension.id)
  return _impl_.id_.Release();
}
inline void Extension::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vortex.dtype.Extension.id)
}

// .vortex.dtype.DType storage_dtype = 2;
inline bool Extension::has_storage_dtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_dtype_ != nullptr);
  return value;
}
inline void Extension::clear_storage_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_dtype_ != nullptr) _impl_.storage_dtype_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::vortex::dtype::DType& Extension::_internal_storage_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::vortex::dtype::DType* p = _impl_.storage_dtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::vortex::dtype::DType&>(::vortex::dtype::_DType_default_instance_);
}
inline const ::vortex::dtype::DType& Extension::storage_dtype() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Extension.storage_dtype)
  return _internal_storage_dtype();
}
inline void Extension::unsafe_arena_set_allocated_storage_dtype(::vortex::dtype::DType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_dtype_);
  }
  _impl_.storage_dtype_ = reinterpret_cast<::vortex::dtype::DType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.Extension.storage_dtype)
}
inline ::vortex::dtype::DType* Extension::release_storage_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::vortex::dtype::DType* released = _impl_.storage_dtype_;
  _impl_.storage_dtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::vortex::dtype::DType* Extension::unsafe_arena_release_storage_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:vortex.dtype.Extension.storage_dtype)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::vortex::dtype::DType* temp = _impl_.storage_dtype_;
  _impl_.storage_dtype_ = nullptr;
  return temp;
}
inline ::vortex::dtype::DType* Extension::_internal_mutable_storage_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_dtype_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::DType>(GetArena());
    _impl_.storage_dtype_ = reinterpret_cast<::vortex::dtype::DType*>(p);
  }
  return _impl_.storage_dtype_;
}
inline ::vortex::dtype::DType* Extension::mutable_storage_dtype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::vortex::dtype::DType* _msg = _internal_mutable_storage_dtype();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Extension.storage_dtype)
  return _msg;
}
inline void Extension::set_allocated_storage_dtype(::vortex::dtype::DType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.storage_dtype_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.storage_dtype_ = reinterpret_cast<::vortex::dtype::DType*>(value);
  // @@protoc_insertion_point(field_set_allocated:vortex.dtype.Extension.storage_dtype)
}

// optional bytes metadata = 3;
inline bool Extension::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Extension::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Extension.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Extension::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vortex.dtype.Extension.metadata)
}
inline std::string* Extension::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Extension.metadata)
  return _s;
}
inline const std::string& Extension::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.Get();
}
inline void Extension::_internal_set_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* Extension::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* Extension::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:vortex.dtype.Extension.metadata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.metadata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Extension::set_allocated_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vortex.dtype.Extension.metadata)
}

// -------------------------------------------------------------------

// DType

// .vortex.dtype.Null null = 1;
inline bool DType::has_null() const {
  return dtype_type_case() == kNull;
}
inline bool DType::_internal_has_null() const {
  return dtype_type_case() == kNull;
}
inline void DType::set_has_null() {
  _impl_._oneof_case_[0] = kNull;
}
inline void DType::clear_null() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kNull) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.null_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.null_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Null* DType::release_null() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.null)
  if (dtype_type_case() == kNull) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.null_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Null& DType::_internal_null() const {
  return dtype_type_case() == kNull ? *_impl_.dtype_type_.null_ : reinterpret_cast<::vortex::dtype::Null&>(::vortex::dtype::_Null_default_instance_);
}
inline const ::vortex::dtype::Null& DType::null() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.null)
  return _internal_null();
}
inline ::vortex::dtype::Null* DType::unsafe_arena_release_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.null)
  if (dtype_type_case() == kNull) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.null_;
    _impl_.dtype_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_null(::vortex::dtype::Null* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_null();
    _impl_.dtype_type_.null_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.null)
}
inline ::vortex::dtype::Null* DType::_internal_mutable_null() {
  if (dtype_type_case() != kNull) {
    clear_dtype_type();
    set_has_null();
    _impl_.dtype_type_.null_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Null>(GetArena());
  }
  return _impl_.dtype_type_.null_;
}
inline ::vortex::dtype::Null* DType::mutable_null() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Null* _msg = _internal_mutable_null();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.null)
  return _msg;
}

// .vortex.dtype.Bool bool = 2;
inline bool DType::has_bool_() const {
  return dtype_type_case() == kBool;
}
inline bool DType::_internal_has_bool_() const {
  return dtype_type_case() == kBool;
}
inline void DType::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void DType::clear_bool_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kBool) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.bool__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.bool__);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Bool* DType::release_bool_() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.bool)
  if (dtype_type_case() == kBool) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.bool__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Bool& DType::_internal_bool_() const {
  return dtype_type_case() == kBool ? *_impl_.dtype_type_.bool__ : reinterpret_cast<::vortex::dtype::Bool&>(::vortex::dtype::_Bool_default_instance_);
}
inline const ::vortex::dtype::Bool& DType::bool_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.bool)
  return _internal_bool_();
}
inline ::vortex::dtype::Bool* DType::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.bool)
  if (dtype_type_case() == kBool) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.bool__;
    _impl_.dtype_type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_bool_(::vortex::dtype::Bool* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_bool_();
    _impl_.dtype_type_.bool__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.bool)
}
inline ::vortex::dtype::Bool* DType::_internal_mutable_bool_() {
  if (dtype_type_case() != kBool) {
    clear_dtype_type();
    set_has_bool_();
    _impl_.dtype_type_.bool__ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Bool>(GetArena());
  }
  return _impl_.dtype_type_.bool__;
}
inline ::vortex::dtype::Bool* DType::mutable_bool_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Bool* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.bool)
  return _msg;
}

// .vortex.dtype.Primitive primitive = 3;
inline bool DType::has_primitive() const {
  return dtype_type_case() == kPrimitive;
}
inline bool DType::_internal_has_primitive() const {
  return dtype_type_case() == kPrimitive;
}
inline void DType::set_has_primitive() {
  _impl_._oneof_case_[0] = kPrimitive;
}
inline void DType::clear_primitive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kPrimitive) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.primitive_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.primitive_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Primitive* DType::release_primitive() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.primitive)
  if (dtype_type_case() == kPrimitive) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.primitive_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Primitive& DType::_internal_primitive() const {
  return dtype_type_case() == kPrimitive ? *_impl_.dtype_type_.primitive_ : reinterpret_cast<::vortex::dtype::Primitive&>(::vortex::dtype::_Primitive_default_instance_);
}
inline const ::vortex::dtype::Primitive& DType::primitive() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.primitive)
  return _internal_primitive();
}
inline ::vortex::dtype::Primitive* DType::unsafe_arena_release_primitive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.primitive)
  if (dtype_type_case() == kPrimitive) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.primitive_;
    _impl_.dtype_type_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_primitive(::vortex::dtype::Primitive* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_primitive();
    _impl_.dtype_type_.primitive_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.primitive)
}
inline ::vortex::dtype::Primitive* DType::_internal_mutable_primitive() {
  if (dtype_type_case() != kPrimitive) {
    clear_dtype_type();
    set_has_primitive();
    _impl_.dtype_type_.primitive_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Primitive>(GetArena());
  }
  return _impl_.dtype_type_.primitive_;
}
inline ::vortex::dtype::Primitive* DType::mutable_primitive() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Primitive* _msg = _internal_mutable_primitive();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.primitive)
  return _msg;
}

// .vortex.dtype.Utf8 utf8 = 5;
inline bool DType::has_utf8() const {
  return dtype_type_case() == kUtf8;
}
inline bool DType::_internal_has_utf8() const {
  return dtype_type_case() == kUtf8;
}
inline void DType::set_has_utf8() {
  _impl_._oneof_case_[0] = kUtf8;
}
inline void DType::clear_utf8() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kUtf8) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.utf8_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.utf8_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Utf8* DType::release_utf8() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.utf8)
  if (dtype_type_case() == kUtf8) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.utf8_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.utf8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Utf8& DType::_internal_utf8() const {
  return dtype_type_case() == kUtf8 ? *_impl_.dtype_type_.utf8_ : reinterpret_cast<::vortex::dtype::Utf8&>(::vortex::dtype::_Utf8_default_instance_);
}
inline const ::vortex::dtype::Utf8& DType::utf8() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.utf8)
  return _internal_utf8();
}
inline ::vortex::dtype::Utf8* DType::unsafe_arena_release_utf8() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.utf8)
  if (dtype_type_case() == kUtf8) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.utf8_;
    _impl_.dtype_type_.utf8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_utf8(::vortex::dtype::Utf8* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_utf8();
    _impl_.dtype_type_.utf8_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.utf8)
}
inline ::vortex::dtype::Utf8* DType::_internal_mutable_utf8() {
  if (dtype_type_case() != kUtf8) {
    clear_dtype_type();
    set_has_utf8();
    _impl_.dtype_type_.utf8_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Utf8>(GetArena());
  }
  return _impl_.dtype_type_.utf8_;
}
inline ::vortex::dtype::Utf8* DType::mutable_utf8() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Utf8* _msg = _internal_mutable_utf8();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.utf8)
  return _msg;
}

// .vortex.dtype.Binary binary = 6;
inline bool DType::has_binary() const {
  return dtype_type_case() == kBinary;
}
inline bool DType::_internal_has_binary() const {
  return dtype_type_case() == kBinary;
}
inline void DType::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void DType::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.binary_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Binary* DType::release_binary() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.binary)
  if (dtype_type_case() == kBinary) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.binary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Binary& DType::_internal_binary() const {
  return dtype_type_case() == kBinary ? *_impl_.dtype_type_.binary_ : reinterpret_cast<::vortex::dtype::Binary&>(::vortex::dtype::_Binary_default_instance_);
}
inline const ::vortex::dtype::Binary& DType::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.binary)
  return _internal_binary();
}
inline ::vortex::dtype::Binary* DType::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.binary)
  if (dtype_type_case() == kBinary) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.binary_;
    _impl_.dtype_type_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_binary(::vortex::dtype::Binary* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_binary();
    _impl_.dtype_type_.binary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.binary)
}
inline ::vortex::dtype::Binary* DType::_internal_mutable_binary() {
  if (dtype_type_case() != kBinary) {
    clear_dtype_type();
    set_has_binary();
    _impl_.dtype_type_.binary_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Binary>(GetArena());
  }
  return _impl_.dtype_type_.binary_;
}
inline ::vortex::dtype::Binary* DType::mutable_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Binary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.binary)
  return _msg;
}

// .vortex.dtype.Struct struct = 7;
inline bool DType::has_struct_() const {
  return dtype_type_case() == kStruct;
}
inline bool DType::_internal_has_struct_() const {
  return dtype_type_case() == kStruct;
}
inline void DType::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void DType::clear_struct_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.struct__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.struct__);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Struct* DType::release_struct_() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.struct)
  if (dtype_type_case() == kStruct) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.struct__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Struct& DType::_internal_struct_() const {
  return dtype_type_case() == kStruct ? *_impl_.dtype_type_.struct__ : reinterpret_cast<::vortex::dtype::Struct&>(::vortex::dtype::_Struct_default_instance_);
}
inline const ::vortex::dtype::Struct& DType::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.struct)
  return _internal_struct_();
}
inline ::vortex::dtype::Struct* DType::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.struct)
  if (dtype_type_case() == kStruct) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.struct__;
    _impl_.dtype_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_struct_(::vortex::dtype::Struct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_struct_();
    _impl_.dtype_type_.struct__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.struct)
}
inline ::vortex::dtype::Struct* DType::_internal_mutable_struct_() {
  if (dtype_type_case() != kStruct) {
    clear_dtype_type();
    set_has_struct_();
    _impl_.dtype_type_.struct__ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Struct>(GetArena());
  }
  return _impl_.dtype_type_.struct__;
}
inline ::vortex::dtype::Struct* DType::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.struct)
  return _msg;
}

// .vortex.dtype.List list = 8;
inline bool DType::has_list() const {
  return dtype_type_case() == kList;
}
inline bool DType::_internal_has_list() const {
  return dtype_type_case() == kList;
}
inline void DType::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void DType::clear_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.list_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::List* DType::release_list() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.list)
  if (dtype_type_case() == kList) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::List& DType::_internal_list() const {
  return dtype_type_case() == kList ? *_impl_.dtype_type_.list_ : reinterpret_cast<::vortex::dtype::List&>(::vortex::dtype::_List_default_instance_);
}
inline const ::vortex::dtype::List& DType::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.list)
  return _internal_list();
}
inline ::vortex::dtype::List* DType::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.list)
  if (dtype_type_case() == kList) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.list_;
    _impl_.dtype_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_list(::vortex::dtype::List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_list();
    _impl_.dtype_type_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.list)
}
inline ::vortex::dtype::List* DType::_internal_mutable_list() {
  if (dtype_type_case() != kList) {
    clear_dtype_type();
    set_has_list();
    _impl_.dtype_type_.list_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::List>(GetArena());
  }
  return _impl_.dtype_type_.list_;
}
inline ::vortex::dtype::List* DType::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.list)
  return _msg;
}

// .vortex.dtype.Extension extension = 9;
inline bool DType::has_extension() const {
  return dtype_type_case() == kExtension;
}
inline bool DType::_internal_has_extension() const {
  return dtype_type_case() == kExtension;
}
inline void DType::set_has_extension() {
  _impl_._oneof_case_[0] = kExtension;
}
inline void DType::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (dtype_type_case() == kExtension) {
    if (GetArena() == nullptr) {
      delete _impl_.dtype_type_.extension_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.dtype_type_.extension_);
    }
    clear_has_dtype_type();
  }
}
inline ::vortex::dtype::Extension* DType::release_extension() {
  // @@protoc_insertion_point(field_release:vortex.dtype.DType.extension)
  if (dtype_type_case() == kExtension) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.extension_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dtype_type_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vortex::dtype::Extension& DType::_internal_extension() const {
  return dtype_type_case() == kExtension ? *_impl_.dtype_type_.extension_ : reinterpret_cast<::vortex::dtype::Extension&>(::vortex::dtype::_Extension_default_instance_);
}
inline const ::vortex::dtype::Extension& DType::extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.DType.extension)
  return _internal_extension();
}
inline ::vortex::dtype::Extension* DType::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vortex.dtype.DType.extension)
  if (dtype_type_case() == kExtension) {
    clear_has_dtype_type();
    auto* temp = _impl_.dtype_type_.extension_;
    _impl_.dtype_type_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DType::unsafe_arena_set_allocated_extension(::vortex::dtype::Extension* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_dtype_type();
  if (value) {
    set_has_extension();
    _impl_.dtype_type_.extension_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vortex.dtype.DType.extension)
}
inline ::vortex::dtype::Extension* DType::_internal_mutable_extension() {
  if (dtype_type_case() != kExtension) {
    clear_dtype_type();
    set_has_extension();
    _impl_.dtype_type_.extension_ =
        ::google::protobuf::Message::DefaultConstruct<::vortex::dtype::Extension>(GetArena());
  }
  return _impl_.dtype_type_.extension_;
}
inline ::vortex::dtype::Extension* DType::mutable_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::vortex::dtype::Extension* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.DType.extension)
  return _msg;
}

inline bool DType::has_dtype_type() const {
  return dtype_type_case() != DTYPE_TYPE_NOT_SET;
}
inline void DType::clear_has_dtype_type() {
  _impl_._oneof_case_[0] = DTYPE_TYPE_NOT_SET;
}
inline DType::DtypeTypeCase DType::dtype_type_case() const {
  return DType::DtypeTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Field

// string name = 1;
inline bool Field::has_name() const {
  return field_type_case() == kName;
}
inline void Field::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void Field::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() == kName) {
    _impl_.field_type_.name_.Destroy();
    clear_has_field_type();
  }
}
inline const std::string& Field::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.Field.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Field::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() != kName) {
    clear_field_type();

    set_has_name();
    _impl_.field_type_.name_.InitDefault();
  }
  _impl_.field_type_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:vortex.dtype.Field.name)
}
inline std::string* Field::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vortex.dtype.Field.name)
  return _s;
}
inline const std::string& Field::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (field_type_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.field_type_.name_.Get();
}
inline void Field::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() != kName) {
    clear_field_type();

    set_has_name();
    _impl_.field_type_.name_.InitDefault();
  }
  _impl_.field_type_.name_.Set(value, GetArena());
}
inline std::string* Field::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() != kName) {
    clear_field_type();

    set_has_name();
    _impl_.field_type_.name_.InitDefault();
  }
  return _impl_.field_type_.name_.Mutable( GetArena());
}
inline std::string* Field::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:vortex.dtype.Field.name)
  if (field_type_case() != kName) {
    return nullptr;
  }
  clear_has_field_type();
  return _impl_.field_type_.name_.Release();
}
inline void Field::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_field_type()) {
    clear_field_type();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.field_type_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:vortex.dtype.Field.name)
}

inline bool Field::has_field_type() const {
  return field_type_case() != FIELD_TYPE_NOT_SET;
}
inline void Field::clear_has_field_type() {
  _impl_._oneof_case_[0] = FIELD_TYPE_NOT_SET;
}
inline Field::FieldTypeCase Field::field_type_case() const {
  return Field::FieldTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FieldPath

// repeated .vortex.dtype.Field path = 1;
inline int FieldPath::_internal_path_size() const {
  return _internal_path().size();
}
inline int FieldPath::path_size() const {
  return _internal_path_size();
}
inline void FieldPath::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
}
inline ::vortex::dtype::Field* FieldPath::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:vortex.dtype.FieldPath.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>* FieldPath::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:vortex.dtype.FieldPath.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::vortex::dtype::Field& FieldPath::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:vortex.dtype.FieldPath.path)
  return _internal_path().Get(index);
}
inline ::vortex::dtype::Field* FieldPath::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::vortex::dtype::Field* _add = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add:vortex.dtype.FieldPath.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>& FieldPath::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:vortex.dtype.FieldPath.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>&
FieldPath::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::vortex::dtype::Field>*
FieldPath::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dtype
}  // namespace vortex


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::vortex::dtype::PType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::vortex::dtype::PType>() {
  return ::vortex::dtype::PType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dtype_2eproto_2epb_2eh
